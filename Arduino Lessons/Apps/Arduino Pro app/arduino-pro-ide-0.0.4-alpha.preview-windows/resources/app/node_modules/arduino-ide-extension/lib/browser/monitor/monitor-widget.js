"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var dateFormat = require("dateformat");
var inversify_1 = require("inversify");
var os_1 = require("@theia/core/lib/common/os");
var event_1 = require("@theia/core/lib/common/event");
var keys_1 = require("@theia/core/lib/browser/keys");
var disposable_1 = require("@theia/core/lib/common/disposable");
var widgets_1 = require("@theia/core/lib/browser/widgets");
var boards_service_1 = require("../../common/protocol/boards-service");
var arduino_select_1 = require("../components/arduino-select");
var monitor_model_1 = require("./monitor-model");
var monitor_connection_1 = require("./monitor-connection");
var monitor_service_client_impl_1 = require("./monitor-service-client-impl");
var MonitorWidget = /** @class */ (function (_super) {
    __extends(MonitorWidget, _super);
    function MonitorWidget() {
        var _this = _super.call(this) || this;
        /**
         * Guard against re-rendering the view after the close was requested.
         * See: https://github.com/eclipse-theia/theia/issues/6704
         */
        _this.closing = false;
        _this.clearOutputEmitter = new event_1.Emitter();
        _this.onFocusResolved = function (element) {
            _this.focusNode = element;
            requestAnimationFrame(function () { return widgets_1.MessageLoop.sendMessage(_this, widgets_1.Widget.Msg.ActivateRequest); });
        };
        _this.onSend = function (value) { return _this.doSend(value); };
        _this.onChangeLineEnding = function (option) {
            _this.monitorModel.lineEnding = option.value;
        };
        _this.onChangeBaudRate = function (option) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.monitorModel.baudRate = option.value;
                return [2 /*return*/];
            });
        }); };
        _this.id = MonitorWidget_1.ID;
        _this.title.label = 'Serial Monitor';
        _this.title.iconClass = 'arduino-serial-monitor-tab-icon';
        _this.title.closable = true;
        _this.scrollOptions = undefined;
        _this.toDispose.push(_this.clearOutputEmitter);
        return _this;
    }
    MonitorWidget_1 = MonitorWidget;
    MonitorWidget.prototype.init = function () {
        var _this = this;
        this.update();
        this.toDispose.push(this.monitorConnection.onConnectionChanged(function () { return _this.clearConsole(); }));
    };
    MonitorWidget.prototype.clearConsole = function () {
        this.clearOutputEmitter.fire(undefined);
        this.update();
    };
    MonitorWidget.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    MonitorWidget.prototype.onAfterAttach = function (msg) {
        _super.prototype.onAfterAttach.call(this, msg);
        this.monitorConnection.autoConnect = true;
    };
    MonitorWidget.prototype.onCloseRequest = function (msg) {
        this.closing = true;
        this.monitorConnection.autoConnect = false;
        if (this.monitorConnection.connected) {
            this.monitorConnection.disconnect();
        }
        _super.prototype.onCloseRequest.call(this, msg);
    };
    MonitorWidget.prototype.onUpdateRequest = function (msg) {
        // TODO: `this.isAttached`
        // See: https://github.com/eclipse-theia/theia/issues/6704#issuecomment-562574713
        if (!this.closing && this.isAttached) {
            _super.prototype.onUpdateRequest.call(this, msg);
        }
    };
    MonitorWidget.prototype.onResize = function (msg) {
        _super.prototype.onResize.call(this, msg);
        this.widgetHeight = msg.height;
        this.update();
    };
    MonitorWidget.prototype.onActivateRequest = function (msg) {
        _super.prototype.onActivateRequest.call(this, msg);
        (this.focusNode || this.node).focus();
    };
    Object.defineProperty(MonitorWidget.prototype, "lineEndings", {
        get: function () {
            return [
                {
                    label: 'No Line Ending',
                    value: ''
                },
                {
                    label: 'New Line',
                    value: '\n'
                },
                {
                    label: 'Carriage Return',
                    value: '\r'
                },
                {
                    label: 'Both NL & CR',
                    value: '\r\n'
                }
            ];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MonitorWidget.prototype, "baudRates", {
        get: function () {
            var baudRates = [300, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200];
            return baudRates.map(function (baudRate) { return ({ label: baudRate + ' baud', value: baudRate }); });
        },
        enumerable: true,
        configurable: true
    });
    MonitorWidget.prototype.render = function () {
        var _this = this;
        var _a = this, baudRates = _a.baudRates, lineEndings = _a.lineEndings;
        var lineEnding = lineEndings.find(function (item) { return item.value === _this.monitorModel.lineEnding; }) || lineEndings[1]; // Defaults to `\n`.
        var baudRate = baudRates.find(function (item) { return item.value === _this.monitorModel.baudRate; }) || baudRates[4]; // Defaults to `9600`.
        return React.createElement("div", { className: 'serial-monitor' },
            React.createElement("div", { className: 'head' },
                React.createElement("div", { className: 'send' },
                    React.createElement(SerialMonitorSendInput, { monitorConfig: this.monitorConnection.monitorConfig, resolveFocus: this.onFocusResolved, onSend: this.onSend })),
                React.createElement("div", { className: 'config' },
                    React.createElement("div", { className: 'select' },
                        React.createElement(arduino_select_1.ArduinoSelect, { maxMenuHeight: this.widgetHeight - 40, options: lineEndings, defaultValue: lineEnding, onChange: this.onChangeLineEnding })),
                    React.createElement("div", { className: 'select' },
                        React.createElement(arduino_select_1.ArduinoSelect, { className: 'select', maxMenuHeight: this.widgetHeight - 40, options: baudRates, defaultValue: baudRate, onChange: this.onChangeBaudRate })))),
            React.createElement("div", { className: 'body' },
                React.createElement(SerialMonitorOutput, { monitorModel: this.monitorModel, monitorConnection: this.monitorConnection, clearConsoleEvent: this.clearOutputEmitter.event })));
    };
    MonitorWidget.prototype.doSend = function (value) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.monitorConnection.send(value);
                return [2 /*return*/];
            });
        });
    };
    var MonitorWidget_1;
    MonitorWidget.ID = 'serial-monitor';
    __decorate([
        inversify_1.inject(monitor_model_1.MonitorModel),
        __metadata("design:type", monitor_model_1.MonitorModel)
    ], MonitorWidget.prototype, "monitorModel", void 0);
    __decorate([
        inversify_1.inject(monitor_connection_1.MonitorConnection),
        __metadata("design:type", monitor_connection_1.MonitorConnection)
    ], MonitorWidget.prototype, "monitorConnection", void 0);
    __decorate([
        inversify_1.inject(monitor_service_client_impl_1.MonitorServiceClientImpl),
        __metadata("design:type", monitor_service_client_impl_1.MonitorServiceClientImpl)
    ], MonitorWidget.prototype, "monitorServiceClient", void 0);
    __decorate([
        inversify_1.postConstruct(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], MonitorWidget.prototype, "init", null);
    MonitorWidget = MonitorWidget_1 = __decorate([
        inversify_1.injectable(),
        __metadata("design:paramtypes", [])
    ], MonitorWidget);
    return MonitorWidget;
}(widgets_1.ReactWidget));
exports.MonitorWidget = MonitorWidget;
var SerialMonitorSendInput = /** @class */ (function (_super) {
    __extends(SerialMonitorSendInput, _super);
    function SerialMonitorSendInput(props) {
        var _this = _super.call(this, props) || this;
        _this.setRef = function (element) {
            if (_this.props.resolveFocus) {
                _this.props.resolveFocus(element || undefined);
            }
        };
        _this.state = { text: '' };
        _this.onChange = _this.onChange.bind(_this);
        _this.onSend = _this.onSend.bind(_this);
        _this.onKeyDown = _this.onKeyDown.bind(_this);
        return _this;
    }
    SerialMonitorSendInput.prototype.render = function () {
        return React.createElement("input", { ref: this.setRef, type: 'text', className: this.props.monitorConfig ? '' : 'warning', placeholder: this.placeholder, value: this.state.text, onChange: this.onChange, onKeyDown: this.onKeyDown });
    };
    Object.defineProperty(SerialMonitorSendInput.prototype, "placeholder", {
        get: function () {
            var monitorConfig = this.props.monitorConfig;
            if (!monitorConfig) {
                return 'Not connected. Select a board and a port to connect automatically.';
            }
            var board = monitorConfig.board, port = monitorConfig.port;
            return "Message (" + (os_1.isOSX ? 'âŒ˜' : 'Ctrl') + "+Enter to send message to '" + boards_service_1.Board.toString(board, { useFqbn: false }) + "' on '" + boards_service_1.Port.toString(port) + "')";
        },
        enumerable: true,
        configurable: true
    });
    SerialMonitorSendInput.prototype.onChange = function (event) {
        this.setState({ text: event.target.value });
    };
    SerialMonitorSendInput.prototype.onSend = function () {
        this.props.onSend(this.state.text);
        this.setState({ text: '' });
    };
    SerialMonitorSendInput.prototype.onKeyDown = function (event) {
        var keyCode = keys_1.KeyCode.createKeyCode(event.nativeEvent);
        if (keyCode) {
            var key = keyCode.key, meta = keyCode.meta, ctrl = keyCode.ctrl;
            if (key === keys_1.Key.ENTER && ((os_1.isOSX && meta) || (!os_1.isOSX && ctrl))) {
                this.onSend();
            }
        }
    };
    return SerialMonitorSendInput;
}(React.Component));
exports.SerialMonitorSendInput = SerialMonitorSendInput;
var SerialMonitorOutput = /** @class */ (function (_super) {
    __extends(SerialMonitorOutput, _super);
    function SerialMonitorOutput(props) {
        var _this = _super.call(this, props) || this;
        _this.toDisposeBeforeUnmount = new disposable_1.DisposableCollection();
        _this.state = { content: '', timestamp: _this.props.monitorModel.timestamp };
        return _this;
    }
    SerialMonitorOutput.prototype.render = function () {
        var _this = this;
        return React.createElement(React.Fragment, null,
            React.createElement("div", { style: ({ whiteSpace: 'pre', fontFamily: 'monospace' }) }, this.state.content),
            React.createElement("div", { style: { float: 'left', clear: 'both' }, ref: function (element) { _this.anchor = element; } }));
    };
    SerialMonitorOutput.prototype.componentDidMount = function () {
        var _this = this;
        this.scrollToBottom();
        var chunk = '';
        this.toDisposeBeforeUnmount.pushAll([
            this.props.monitorConnection.onRead(function (_a) {
                var data = _a.data;
                chunk += data;
                var eolIndex = chunk.indexOf('\n');
                if (eolIndex !== -1) {
                    var line = chunk.substring(0, eolIndex + 1);
                    chunk = chunk.slice(eolIndex + 1);
                    var content = "" + _this.state.content + (_this.state.timestamp ? dateFormat(new Date(), 'H:M:ss.l') + " -> " : '') + line;
                    _this.setState({ content: content });
                }
            }),
            this.props.clearConsoleEvent(function () { return _this.setState({ content: '' }); }),
            this.props.monitorModel.onChange(function (_a) {
                var property = _a.property;
                if (property === 'timestamp') {
                    var timestamp = _this.props.monitorModel.timestamp;
                    _this.setState({ timestamp: timestamp });
                }
            })
        ]);
    };
    SerialMonitorOutput.prototype.componentDidUpdate = function () {
        this.scrollToBottom();
    };
    SerialMonitorOutput.prototype.componentWillUnmount = function () {
        // TODO: "Your preferred browser's local storage is almost full." Discard `content` before saving layout?
        this.toDisposeBeforeUnmount.dispose();
    };
    SerialMonitorOutput.prototype.scrollToBottom = function () {
        if (this.props.monitorModel.autoscroll && this.anchor) {
            this.anchor.scrollIntoView();
        }
    };
    return SerialMonitorOutput;
}(React.Component));
exports.SerialMonitorOutput = SerialMonitorOutput;
//# sourceMappingURL=monitor-widget.js.map